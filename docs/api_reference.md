# SerialKit Generated API Reference

Complete reference for using C++ code generated by SerialKit.

## Table of Contents

1. [Overview](#overview)
2. [Generated Files](#generated-files)
3. [Enum API](#enum-api)
4. [Model API](#model-api)
5. [Serialization](#serialization)
6. [Deserialization](#deserialization)
7. [Field Access](#field-access)
8. [Type Mappings](#type-mappings)
9. [Error Handling](#error-handling)
10. [Best Practices](#best-practices)

## Overview

SerialKit generates two C++ files from each `.skit` schema:
- **Header file** (`.hpp`) - Class declarations
- **Source file** (`.cpp`) - Implementation of serialize/deserialize

Generated code is:
- **Self-contained** - no runtime dependencies
- **C++20 compatible** - uses modern C++ features
- **Type-safe** - strong typing with enums and models
- **Zero-copy optimized** - efficient memory usage

## Generated Files

### Input Schema

```cpp
// user.skit
namespace myapp;

enum Role {
    GUEST = 0;
    USER = 1;
}

model User {
    string username = 1;
    uint32 id = 2;
}
```

### Generated Files

```bash
# Compile
serialkit-compiler user.skit -o gen/

# Creates
gen/myapp.hpp     # Header with declarations
gen/myapp.cpp     # Implementation
```

### Using Generated Code

```cpp
#include "gen/myapp.hpp"

int main() {
    myapp::User user;
    user.username = "alice";
    // ...
}
```

## Enum API

### Generated Enum

Schema:
```cpp
enum Status {
    INACTIVE = 0;
    ACTIVE = 1;
    SUSPENDED = 2;
}
```

Generated:
```cpp
enum class Status : int32_t {
    INACTIVE = 0,
    ACTIVE = 1,
    SUSPENDED = 2
};
```

### Usage

```cpp
// Declaration
myapp::Status status;

// Assignment
status = myapp::Status::ACTIVE;

// Comparison
if (status == myapp::Status::ACTIVE) {
    std::cout << "Active!\n";
}

// Switch statement
switch (status) {
    case myapp::Status::INACTIVE:
        // ...
        break;
    case myapp::Status::ACTIVE:
        // ...
        break;
    case myapp::Status::SUSPENDED:
        // ...
        break;
}

// Cast to/from integer
int32_t value = static_cast<int32_t>(status);
myapp::Status from_int = static_cast<myapp::Status>(1);
```

## Model API

### Generated Model Class

Schema:
```cpp
model User {
    string username = 1;
    uint32 user_id = 2;
    optional string email = 3;
    repeated string tags = 4;
}
```

Generated:
```cpp
class User {
public:
    User() = default;

    std::string username;
    uint32_t user_id = 0;
    std::optional<std::string> email;
    std::vector<std::string> tags;

    std::vector<uint8_t> serialize() const;
    bool deserialize(const std::vector<uint8_t>& data);
};
```

### Member Variables

All fields are **public member variables**:

```cpp
User user;
user.username = "alice";      // Direct access
user.user_id = 12345;
```

### Default Values

- Numeric types: `0`
- `bool`: `false`
- `string`: `""` (empty)
- `optional<T>`: not set (`.has_value()` returns false)
- `repeated<T>`: `[]` (empty vector)
- Enums: Default constructed (first value or 0)

## Serialization

### serialize() Method

```cpp
std::vector<uint8_t> serialize() const;
```

Converts the object to binary data.

**Returns**: `std::vector<uint8_t>` containing serialized bytes

**Example**:
```cpp
User user;
user.username = "alice";
user.user_id = 123;

// Serialize to binary
std::vector<uint8_t> data = user.serialize();

// Use the data
std::cout << "Size: " << data.size() << " bytes\n";
save_to_file("user.bin", data);
send_over_network(data);
```

### Binary Data

The serialized data is:
- **Compact** - variable-length encoding
- **Self-describing** - contains field tags
- **Platform-independent** - little-endian, portable

## Deserialization

### deserialize() Method

```cpp
bool deserialize(const std::vector<uint8_t>& data);
```

Populates the object from binary data.

**Parameters**:
- `data` - Binary data to deserialize

**Returns**: 
- `true` - Deserialization succeeded
- `false` - Deserialization failed (corrupted data)

**Example**:
```cpp
std::vector<uint8_t> data = load_from_file("user.bin");

User user;
if (user.deserialize(data)) {
    std::cout << "User: " << user.username << "\n";
} else {
    std::cerr << "Failed to deserialize!\n";
}
```

### Deserialization Behavior

- **Unknown fields**: Silently skipped (forward compatibility)
- **Missing fields**: Left at default values
- **Type mismatches**: Deserialization fails, returns false
- **Truncated data**: Deserialization fails, returns false

## Field Access

### Required Fields

```cpp
model User {
    string username = 1;
    uint32 id = 2;
}
```

Direct access:
```cpp
User user;
user.username = "alice";
user.id = 123;

std::cout << user.username << "\n";
std::cout << user.id << "\n";
```

### Optional Fields

```cpp
model User {
    optional string email = 1;
    optional uint32 age = 2;
}
```

Using `std::optional`:
```cpp
User user;

// Set optional field
user.email = "alice@example.com";
user.age = 30;

// Check if set
if (user.email.has_value()) {
    std::cout << "Email: " << *user.email << "\n";
}

// Access with default
std::cout << user.email.value_or("no-email") << "\n";

// Reset
user.email.reset();  // or user.email = std::nullopt;
```

### Repeated Fields

```cpp
model User {
    repeated string tags = 1;
    repeated uint32 scores = 2;
}
```

Using `std::vector`:
```cpp
User user;

// Add elements
user.tags.push_back("admin");
user.tags.push_back("verified");

// Access elements
for (const auto& tag : user.tags) {
    std::cout << tag << "\n";
}

// Random access
if (!user.tags.empty()) {
    std::cout << "First: " << user.tags[0] << "\n";
}

// Size
std::cout << "Count: " << user.tags.size() << "\n";

// Clear
user.tags.clear();

// Reserve space
user.scores.reserve(100);
```

### Nested Models

```cpp
model Address {
    string city = 1;
    string country = 2;
}

model Person {
    string name = 1;
    Address address = 2;
}
```

Access:
```cpp
Person person;
person.name = "Alice";

// Access nested fields
person.address.city = "New York";
person.address.country = "USA";

// Can also construct separately
Address addr;
addr.city = "Boston";
addr.country = "USA";
person.address = addr;
```

## Type Mappings

### Primitive Types

| Schema Type | C++ Type | Header | Default |
|-------------|----------|--------|---------|
| `int8` | `int8_t` | `<cstdint>` | `0` |
| `int16` | `int16_t` | `<cstdint>` | `0` |
| `int32` | `int32_t` | `<cstdint>` | `0` |
| `int64` | `int64_t` | `<cstdint>` | `0` |
| `uint8` | `uint8_t` | `<cstdint>` | `0` |
| `uint16` | `uint16_t` | `<cstdint>` | `0` |
| `uint32` | `uint32_t` | `<cstdint>` | `0` |
| `uint64` | `uint64_t` | `<cstdint>` | `0` |
| `float` | `float` | - | `0.0f` |
| `double` | `double` | - | `0.0` |
| `bool` | `bool` | - | `false` |
| `string` | `std::string` | `<string>` | `""` |
| `byte` | `uint8_t` | `<cstdint>` | `0` |

### Modifier Mappings

| Schema Modifier | C++ Type | Header |
|-----------------|----------|--------|
| `optional T` | `std::optional<T>` | `<optional>` |
| `repeated T` | `std::vector<T>` | `<vector>` |

### User Types

| Schema Type | C++ Type |
|-------------|----------|
| `enum EnumName` | `EnumName` (enum class) |
| `model ModelName` | `ModelName` (class) |

## Error Handling

### Deserialization Errors

```cpp
std::vector<uint8_t> data = load_data();

User user;
if (!user.deserialize(data)) {
    // Handle error
    std::cerr << "Deserialization failed!\n";
    // Possible causes:
    // - Corrupted data
    // - Truncated data
    // - Incompatible schema version
    return;
}

// Success - use user
std::cout << user.username << "\n";
```

### Field Validation

Generated code doesn't validate field values. You should add validation:

```cpp
User user;
user.deserialize(data);

// Validate username
if (user.username.empty()) {
    throw std::invalid_argument("Username cannot be empty");
}

// Validate email format
if (user.email.has_value() && !is_valid_email(*user.email)) {
    throw std::invalid_argument("Invalid email format");
}
```

## Best Practices

### 1. Use References for Large Objects

```cpp
// ❌ AVOID: Copies the user
User get_user() {
    User user = load_user();
    return user;  // Copy
}

// ✅ BETTER: Move semantics
User get_user() {
    User user = load_user();
    return user;  // Moved (C++17+)
}

// ✅ BEST: Return by reference or pointer when possible
const User& get_user_ref();
```

### 2. Reserve Vector Capacity

```cpp
User user;

// ✅ GOOD: Reserve when size is known
user.tags.reserve(expected_count);
for (int i = 0; i < expected_count; ++i) {
    user.tags.push_back(generate_tag(i));
}
```

### 3. Check Optional Fields

```cpp
// ❌ DANGEROUS: May crash if not set
std::cout << *user.email << "\n";

// ✅ SAFE: Check first
if (user.email.has_value()) {
    std::cout << *user.email << "\n";
}

// ✅ SAFE: Use value_or
std::cout << user.email.value_or("no-email") << "\n";
```

### 4. Reuse Objects

```cpp
// ✅ GOOD: Reuse to avoid allocations
User user;
for (const auto& data_chunk : data_chunks) {
    if (user.deserialize(data_chunk)) {
        process(user);
        // user will be overwritten in next iteration
    }
}
```

### 5. Move Large Fields

```cpp
// ❌ AVOID: Copies large string
std::string large_data = generate_large_string();
user.data = large_data;  // Copy

// ✅ BETTER: Move
user.data = std::move(large_data);  // Move, large_data is now empty
```

### 6. Batch Serialization

```cpp
// Serialize multiple users efficiently
std::vector<uint8_t> serialize_users(const std::vector<User>& users) {
    std::vector<uint8_t> result;
    
    // Calculate total size to reserve
    size_t total_size = 0;
    for (const auto& user : users) {
        total_size += user.serialize().size();
    }
    result.reserve(total_size);
    
    // Serialize all
    for (const auto& user : users) {
        auto data = user.serialize();
        result.insert(result.end(), data.begin(), data.end());
    }
    
    return result;
}
```

## Complete Example

### Schema

```cpp
// game.skit
namespace game;

enum PlayerState {
    IDLE = 0;
    MOVING = 1;
    ATTACKING = 2;
}

model Vector3 {
    float x = 1;
    float y = 2;
    float z = 3;
}

model Player {
    uint32 player_id = 1;
    string name = 2;
    Vector3 position = 3;
    PlayerState state = 4;
    optional uint32 health = 5;
    repeated string inventory = 6;
}
```

### Usage

```cpp
#include "gen/game.hpp"
#include <iostream>
#include <fstream>

int main() {
    // Create player
    game::Player player;
    player.player_id = 12345;
    player.name = "Alice";
    player.position.x = 10.5f;
    player.position.y = 20.0f;
    player.position.z = 5.5f;
    player.state = game::PlayerState::MOVING;
    player.health = 100;
    player.inventory.push_back("sword");
    player.inventory.push_back("shield");
    
    // Serialize to file
    std::vector<uint8_t> data = player.serialize();
    std::ofstream out("player.bin", std::ios::binary);
    out.write(reinterpret_cast<const char*>(data.data()), data.size());
    out.close();
    
    // Load from file
    std::ifstream in("player.bin", std::ios::binary);
    in.seekg(0, std::ios::end);
    size_t size = in.tellg();
    in.seekg(0, std::ios::beg);
    std::vector<uint8_t> loaded_data(size);
    in.read(reinterpret_cast<char*>(loaded_data.data()), size);
    in.close();
    
    // Deserialize
    game::Player loaded_player;
    if (loaded_player.deserialize(loaded_data)) {
        std::cout << "Player ID: " << loaded_player.player_id << "\n";
        std::cout << "Name: " << loaded_player.name << "\n";
        std::cout << "Position: (" 
                  << loaded_player.position.x << ", "
                  << loaded_player.position.y << ", "
                  << loaded_player.position.z << ")\n";
        
        if (loaded_player.health.has_value()) {
            std::cout << "Health: " << *loaded_player.health << "\n";
        }
        
        std::cout << "Inventory:\n";
        for (const auto& item : loaded_player.inventory) {
            std::cout << "  - " << item << "\n";
        }
    }
    
    return 0;
}
```

### Compilation

```bash
g++ -std=c++20 main.cpp gen/game.cpp -o game
./game
```

## See Also

- [Tutorial](tutorial.md) - Getting started guide
- [DSL Reference](dsl_reference.md) - Schema syntax
- [Wire Format](WIRE_FORMAT.md) - Binary encoding details
- [Examples](../examples/) - Real-world usage
